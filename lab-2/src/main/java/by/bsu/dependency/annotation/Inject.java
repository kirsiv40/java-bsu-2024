package by.bsu.dependency.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Пока тестами функционал {@code canUseLastSameClass} не покрыт.
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Inject {
    /**
     * Попытка разрешить некоторые циклические зависимости. <p>
     * Например, иногда хочется сделать несколько классов с зависимостью,
     * обрузеющий своеобразный блок. И при этом нужно чтобы такой блок был не один.
     * То есть какой-то из этих классов имеет скоуп {@code BeanScope.PROTOTYPE}
     * и хочется при создании экземпляра этого класса для него формировать новый блок классов
     * с циклическими зависимостями, которые хочет в себе содержать первый класс.
     * Видно, что тогда не получится поступить как с {@code BeanScope.SINGLETON}.<p>
     * Параметр true здесь имеет значение только в случае {@code BeanScope.PROTOTYPE} бина. <p>
     * С технической точки зрения указание true в этом параметре приводит к тому, что
     * в поле может оказаться не новый класс типа {@code BeanScope.PROTOTYPE}, а уже созданный ранее.
     * А именно тот, из-за которого может случится циклическая зависимость. <p>
     * Например, пусть класс A имеет поле типа B, класс B имеет поле типа C, С - типов А и B с 
     * модифицированным {@code @Inject}. Тогда всего в каждом блоке будет 3 класса, C будет иметь ссылки на
     * экземпляры классов A и B. Такой {@code @Inject} не гарантирует, что всего будет создано не более одного
     * экземпляра каждого класса внутри блока. Если, например, у класса A есть три поля типа B, а классы B и C 
     * имеют такие же поля, как и раньше, все экземпляры классов B и C будут различны, экземпляры C будут
     * хранить ссылки на разные B, но один и тот же экземпляр A.
     */
    boolean canUseLastSameClass() default false;
}
